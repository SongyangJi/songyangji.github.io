const n=JSON.parse('{"key":"v-bac7f562","path":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20%E2%80%94%E2%80%94%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8F%8AJava%E5%AE%9E%E7%8E%B0.html","title":"设计模式 —— 单例模式及Java实现","lang":"zh-CN","frontmatter":{"title":"设计模式 —— 单例模式及Java实现","date":"2021-11-26T08:20:23.000Z","categories":["设计模式"],"tags":["单例模式","设计模式"],"description":"单例模式 在整个项目中只提供这个类的一个实例，而不是需要这个实例对象时候去创建，用完就销毁。 适用场景 创建此对象时间、空间开销非常大，而实际上这种类的对象具有静态属性，即属于类。 对于不同的调用者，不会因为需求不同，赋予它任意的性质——即这种类只会一种或少数形式创建出对象，完全可以事先创建创建、而后供人调用。 Spring的IOC容器里的对象的存在形式默认就是单例的。 常用于工具类，IO类、连接类的对象生成。 Java实现 饿汉式 在编译时就加载完毕。 //饿汉式 public class Singleton { private final static Singleton singleton = new Singleton(); public static Singleton getSingleton() { return singleton; } }","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20%E2%80%94%E2%80%94%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8F%8AJava%E5%AE%9E%E7%8E%B0.html"}],["meta",{"property":"og:site_name","content":"常潇的技术站"}],["meta",{"property":"og:title","content":"设计模式 —— 单例模式及Java实现"}],["meta",{"property":"og:description","content":"单例模式 在整个项目中只提供这个类的一个实例，而不是需要这个实例对象时候去创建，用完就销毁。 适用场景 创建此对象时间、空间开销非常大，而实际上这种类的对象具有静态属性，即属于类。 对于不同的调用者，不会因为需求不同，赋予它任意的性质——即这种类只会一种或少数形式创建出对象，完全可以事先创建创建、而后供人调用。 Spring的IOC容器里的对象的存在形式默认就是单例的。 常用于工具类，IO类、连接类的对象生成。 Java实现 饿汉式 在编译时就加载完毕。 //饿汉式 public class Singleton { private final static Singleton singleton = new Singleton(); public static Singleton getSingleton() { return singleton; } }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-17T15:13:02.000Z"}],["meta",{"property":"article:author","content":"常潇-KeepCool"}],["meta",{"property":"article:tag","content":"单例模式"}],["meta",{"property":"article:tag","content":"设计模式"}],["meta",{"property":"article:published_time","content":"2021-11-26T08:20:23.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-17T15:13:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"设计模式 —— 单例模式及Java实现\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-11-26T08:20:23.000Z\\",\\"dateModified\\":\\"2024-02-17T15:13:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"常潇-KeepCool\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"适用场景","slug":"适用场景","link":"#适用场景","children":[]},{"level":2,"title":"饿汉式","slug":"饿汉式","link":"#饿汉式","children":[]},{"level":2,"title":"懒汉式","slug":"懒汉式","link":"#懒汉式","children":[{"level":3,"title":"利用同步锁","slug":"利用同步锁","link":"#利用同步锁","children":[]},{"level":3,"title":"利用静态内部类","slug":"利用静态内部类","link":"#利用静态内部类","children":[]},{"level":3,"title":"利用枚举实现单例","slug":"利用枚举实现单例","link":"#利用枚举实现单例","children":[]}]},{"level":2,"title":"能否用“反射”去破坏单例","slug":"能否用-反射-去破坏单例","link":"#能否用-反射-去破坏单例","children":[]}],"git":{"createdTime":1708182782000,"updatedTime":1708182782000,"contributors":[{"name":"jisongyang","email":"jisongyang@kuaishou.com","commits":1}]},"readingTime":{"minutes":3.91,"words":1172},"filePathRelative":"posts/设计模式/设计模式 —— 单例模式及Java实现.md","localizedDate":"2021年11月26日","excerpt":"<h1> 单例模式</h1>\\n<p>在整个项目中只提供这个类的一个实例，而不是需要这个实例对象时候去创建，用完就销毁。</p>\\n<h2> 适用场景</h2>\\n<p>创建此对象时间、空间开销非常大，而实际上这种类的对象具有静态属性，即属于类。\\n对于不同的调用者，不会因为需求不同，赋予它任意的性质——即这种类只会一种或少数形式创建出对象，完全可以事先创建创建、而后供人调用。\\nSpring的IOC容器里的对象的存在形式默认就是单例的。\\n常用于工具类，IO类、连接类的对象生成。</p>\\n<h1> Java实现</h1>\\n<h2> 饿汉式</h2>\\n<p>在编译时就加载完毕。</p>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token comment\\">//饿汉式</span>\\n<span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">class</span> <span class=\\"token class-name\\">Singleton</span> <span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token keyword\\">private</span> <span class=\\"token keyword\\">final</span> <span class=\\"token keyword\\">static</span> <span class=\\"token class-name\\">Singleton</span> singleton <span class=\\"token operator\\">=</span> <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">Singleton</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">static</span> <span class=\\"token class-name\\">Singleton</span> <span class=\\"token function\\">getSingleton</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n        <span class=\\"token keyword\\">return</span> singleton<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{n as data};

import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as o,a as l}from"./app-CN-Tp3xY.js";const s={},n=l('<h1 id="lvs的调度算法简介" tabindex="-1"><a class="header-anchor" href="#lvs的调度算法简介" aria-hidden="true">#</a> LVS的调度算法简介</h1><ol><li><p><strong>轮叫调度（Round Robin）</strong> 调度器通过“轮叫”调度算法<strong>将外部请求按顺序轮流分配到集群中的真实服务器上</strong>，它均等地对待每一台服务器，而不管服务器上实际的连接数和系统负载。大锅饭调度：rr - 纯轮询方式，比较垃圾。把每项请求按顺序在真正服务器中分派</p></li><li><p><strong>加权轮叫（Weighted Round Robin）</strong> 调度器通过“加权轮叫”调度算法<strong>根据真实服务器的不同处理能力来调度访问请求</strong>。这样可以保证处理能力强的服务器能处理更多的访问流量。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。 带权重的大锅饭调度：wrr -带权重轮询方式。把每项请求按顺序在真正服务器中循环分派，但是给能力较大的服务器分派较多的作业。</p></li><li><p><strong>最少链接（Least Connections）</strong> 调度器通过“最少连接”调度算法动态地<strong>将网络请求调度到已建立的链接数最少的服务器上</strong>。如果集群系统的真实服务器具有相近的系统性能，采用“最小连接”调度算法可以较好地均衡负载。 谁不干活就给谁分配：lc - 根据最小连接数分派</p></li><li><p><strong>加权最少链接（Weighted Least Connections）</strong> 在集群系统中的服务器性能差异较大的情况下，调度器采用“加权最少链接”调度算法优化负载均衡性能，具有较高权值的服务器将承受较大比例的活动连接负载。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。 带权重的谁不干活就给谁分配：wlc - 带权重的。机器配置好的权重高</p></li><li><p>基于局部性的最少链接（Locality-Based Least Connections） “基于局部性的最少链接”调度算法是针对目标IP地址的负载均衡，目前<strong>主要用于Cache集群系统</strong>。该算法根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则用“最少链接” 的原则选出一个可用的服务器，将请求发送到该服务器。 基于地区的最少连接调度：lblc - 缓存服务器集群。基于本地的最小连接。把请求传递到负载小的服务器上</p></li><li><p>带复制的基于局部性最少链接（Locality-Based Least Connections with Replication） “带复制的基于局部性最少链接”调度算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统。它与LBLC算法的不同之处是它要维护从一个目标 IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。该算法根据请求的目标IP地址找出该目标IP地址对应的服务器组，按“最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按“最小连接”原则从这个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。 带有复制调度的基于地区的最少连接调度：lblcr - 带复制调度的缓存服务器集群。某页面缓存在服务器A上，被访问次数极高，而其他缓存服务器负载较低，监视是否访问同一页面，如果是访问同一页面则把请求分到其他服务器。</p></li><li><p>目标地址散列（Destination Hashing） “目标地址散列”调度算法<strong>根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器</strong>，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。 目标散列调度：realserver中绑定两个ip。ld判断来者的ISP商，将其转到相应的IP。</p></li><li><p>源地址散列（Source Hashing） “源地址散列”调度算法根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。了解这些算法原理能够在特定的应用场合选择最适合的调度算法，从而尽可能地保持Real Server的最佳利用性。当然也可以自行开发算法，不过这已超出本文范围，请参考有关算法原理的资料。 源散列调度：源地址散列。基于client地址的来源区分。（用的很少）</p></li><li><p>最短的期望的延迟（Shortest Expected Delay Scheduling SED） 基于wlc算法。这个必须举例来说了ABC三台机器分别权重123 ，连接数也分别是123。那么如果使用WLC算法的话一个新请求进入时它可能会分给ABC中的任意一个。使用sed算法后会进行这样一个运算A:（1+1)/1B:（1+2)/2C:（1+3)/3根据运算结果，把连接交给C 。</p></li><li><p>最少队列调度（Never Queue Scheduling NQ） 无需队列。如果有台realserver的连接数＝0就直接分配过去，不需要在进行sed运算。</p></li></ol><blockquote><p>参考文章 http://zh.linuxvirtualserver.org/node/2903</p><p>https://blog.csdn.net/lcl_xiaowugui/article/details/81701949</p><p>https://www.cnblogs.com/lzppcc/articles/3072657.html</p><p>https://blog.51cto.com/blief/1745134</p></blockquote>',3),i=[n];function r(c,a){return t(),o("div",null,i)}const h=e(s,[["render",r],["__file","LVS.html.vue"]]);export{h as default};

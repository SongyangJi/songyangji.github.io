const e=JSON.parse('{"key":"v-541126f0","path":"/posts/Redis/Redis%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%8B%20%E2%80%94%E2%80%94%20%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7.html","title":"Redis系列笔记之 —— 缓存与数据库一致性","lang":"zh-CN","frontmatter":{"title":"Redis系列笔记之 —— 缓存与数据库一致性","date":"2021-10-30T00:00:00.000Z","categories":["Redis"],"tags":["NoSQL","Redis"],"description":"使用缓存的两种模式 Cache-Aside Pattern（旁路缓存模式） 失效：程序先从缓存中读取数据，如果没有命中，则从数据库中读取，成功之后将数据放到缓存中； 命中：程序先从缓存中读取数据，如果命中，则直接返回； 更新：程序先更新数据库，再删除缓存。（这个操作顺序之后在细讲）。 Write-behind（异步缓存写入） 这种使用模式的读缓存机制和上是一样的。但是更新缓存的策略为： 更新时只更新缓存，不直接更新数据库，通过批量异步 的方式来更新数据库。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/Redis/Redis%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%8B%20%E2%80%94%E2%80%94%20%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7.html"}],["meta",{"property":"og:site_name","content":"常潇的技术站"}],["meta",{"property":"og:title","content":"Redis系列笔记之 —— 缓存与数据库一致性"}],["meta",{"property":"og:description","content":"使用缓存的两种模式 Cache-Aside Pattern（旁路缓存模式） 失效：程序先从缓存中读取数据，如果没有命中，则从数据库中读取，成功之后将数据放到缓存中； 命中：程序先从缓存中读取数据，如果命中，则直接返回； 更新：程序先更新数据库，再删除缓存。（这个操作顺序之后在细讲）。 Write-behind（异步缓存写入） 这种使用模式的读缓存机制和上是一样的。但是更新缓存的策略为： 更新时只更新缓存，不直接更新数据库，通过批量异步 的方式来更新数据库。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-17T15:13:02.000Z"}],["meta",{"property":"article:author","content":"常潇-KeepCool"}],["meta",{"property":"article:tag","content":"NoSQL"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:published_time","content":"2021-10-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-17T15:13:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis系列笔记之 —— 缓存与数据库一致性\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-10-30T00:00:00.000Z\\",\\"dateModified\\":\\"2024-02-17T15:13:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"常潇-KeepCool\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"使用缓存的两种模式","slug":"使用缓存的两种模式","link":"#使用缓存的两种模式","children":[{"level":3,"title":"Cache-Aside Pattern（旁路缓存模式）","slug":"cache-aside-pattern-旁路缓存模式","link":"#cache-aside-pattern-旁路缓存模式","children":[]},{"level":3,"title":"Write-behind（异步缓存写入）","slug":"write-behind-异步缓存写入","link":"#write-behind-异步缓存写入","children":[]}]},{"level":2,"title":"具体的更新缓存策略","slug":"具体的更新缓存策略","link":"#具体的更新缓存策略","children":[{"level":3,"title":"先更新缓存，再更新数据库","slug":"先更新缓存-再更新数据库","link":"#先更新缓存-再更新数据库","children":[]},{"level":3,"title":"先更新数据库，再更新缓存","slug":"先更新数据库-再更新缓存","link":"#先更新数据库-再更新缓存","children":[]},{"level":3,"title":"先删除缓存，再更新数据库","slug":"先删除缓存-再更新数据库","link":"#先删除缓存-再更新数据库","children":[]},{"level":3,"title":"先更新数据库，再删除缓存","slug":"先更新数据库-再删除缓存","link":"#先更新数据库-再删除缓存","children":[]}]},{"level":2,"title":"对上面四种方式的总结","slug":"对上面四种方式的总结","link":"#对上面四种方式的总结","children":[{"level":3,"title":"更新缓存还是删除缓存？","slug":"更新缓存还是删除缓存","link":"#更新缓存还是删除缓存","children":[]}]},{"level":2,"title":"推荐的做法","slug":"推荐的做法","link":"#推荐的做法","children":[{"level":3,"title":"设置一个合理的redis过期时间","slug":"设置一个合理的redis过期时间","link":"#设置一个合理的redis过期时间","children":[]},{"level":3,"title":"延迟双删","slug":"延迟双删","link":"#延迟双删","children":[]},{"level":3,"title":"延时的具体实现","slug":"延时的具体实现","link":"#延时的具体实现","children":[]},{"level":3,"title":"删除缓存失败的重试机制","slug":"删除缓存失败的重试机制","link":"#删除缓存失败的重试机制","children":[]}]},{"level":2,"title":"怎么做到强一致性？","slug":"怎么做到强一致性","link":"#怎么做到强一致性","children":[{"level":3,"title":"读写锁","slug":"读写锁","link":"#读写锁","children":[]},{"level":3,"title":"分布式一致性算法","slug":"分布式一致性算法","link":"#分布式一致性算法","children":[]}]},{"level":2,"title":"分布式架构、读写分离环境下的一致性保证","slug":"分布式架构、读写分离环境下的一致性保证","link":"#分布式架构、读写分离环境下的一致性保证","children":[]}],"git":{"createdTime":1708182782000,"updatedTime":1708182782000,"contributors":[{"name":"jisongyang","email":"jisongyang@kuaishou.com","commits":1}]},"readingTime":{"minutes":10.68,"words":3205},"filePathRelative":"posts/Redis/Redis系列笔记之 —— 缓存与数据库一致性.md","localizedDate":"2021年10月30日","excerpt":"<h2> 使用缓存的两种模式</h2>\\n<h3> Cache-Aside Pattern（旁路缓存模式）</h3>\\n<ol>\\n<li>失效：程序先从缓存中读取数据，如果没有命中，则从数据库中读取，成功之后将数据放到缓存中；</li>\\n<li>命中：程序先从缓存中读取数据，如果命中，则直接返回；</li>\\n<li>更新：程序<strong>先更新数据库，再删除缓存</strong>。（这个操作顺序之后在细讲）。</li>\\n</ol>\\n<h3> Write-behind（异步缓存写入）</h3>\\n<p>这种使用模式的读缓存机制和上是一样的。但是更新缓存的策略为：</p>\\n<p><strong>更新时只更新缓存，不直接更新数据库</strong>，通过<strong>批量异步</strong> 的方式来更新数据库。</p>","autoDesc":true}');export{e as data};

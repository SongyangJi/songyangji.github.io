import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as e,a as r}from"./app-CN-Tp3xY.js";const i={},o=r('<p>当希望MySQL能够以更高的性能运行查询时，最好的办法就是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，很多查询优化工作实际上就是遵循一些原则能够按照预想的合理的方式运行。  如上图所示，当向MySQL发送一个请求的时候，MySQL到底做了什么。</p><figure><img src="https://img-blog.csdnimg.cn/20191013222917867.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zpc2hfc3R1ZHlfY3Nkbg==,size_16,color_FFFFFF,t_70" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>客户端发送一条查询给服务器。</li><li>服务器<strong>先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果</strong>。否则进入下一阶段。</li><li>服务器端<strong>进行SQL解析、预处理，再由优化器生成对应的执行计划</strong>。</li><li>MySQL<strong>根据优化器生成的执行计划，再调用存储引擎的API来执行查询</strong>。</li><li>将结果返回给客户端。</li></ol><h2 id="查询缓存" tabindex="-1"><a class="header-anchor" href="#查询缓存" aria-hidden="true">#</a> <strong>查询缓存</strong></h2><p>MySQL查询缓存保存查询返回的完整结构。当查询命中该缓存时，MySQL会立刻返回结果，跳过了解析、优化和执行阶段。  查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生了变化，那么和这个表相关的所有缓存数据都将失效。  MySQL将缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了以下因素，即查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能影响返回结果的信息。  当判断缓存是否命中时，MySQL不会进行解析查询语句，而是直接使用SQL语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。  当查询语句中有一些不确定的数据时，则不会被缓存。例如包含函数NOW()或者CURRENT_DATE()的查询不会缓存。包含任何用户自定义函数，存储函数，用户变量，临时表，mysql数据库中的系统表或者包含任何列级别权限的表，都不会被缓存。  有一点需要注意，MySQL并不是会因为查询中包含一个不确定的函数而不检查查询缓存，因为检查查询缓存之前，MySQL不会解析查询语句，所以也无法知道语句中是否有不确定的函数。  事实则是，如果查询语句中包含任何的不确定的函数，那么其查询结果不会被缓存，因为查询缓存中也无法找到对应的缓存结果。</p><h2 id="解析和预处理" tabindex="-1"><a class="header-anchor" href="#解析和预处理" aria-hidden="true">#</a> <strong>解析和预处理</strong></h2><p>解析器通过关键字将SQL语句进行解析，并生成对应的解析树。MySQL解析器将使用MySQL语法规则验证和解析查询。  预处理器则根据一些MySQL规则进行进一步检查解析书是否合法，例如检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义。</p><h2 id="查询优化器" tabindex="-1"><a class="header-anchor" href="#查询优化器" aria-hidden="true">#</a> <strong>查询优化器</strong></h2><p>查询优化器会将解析树转化成执行计划。一条查询可以有多种执行方法，最后都是返回相同结果。优化器的作用就是找到这其中最好的执行计划。  生成执行计划的过程会消耗较多的时间，特别是存在许多可选的执行计划时。如果在一条SQL语句执行的过程中将该语句对应的最终执行计划进行缓存，当相似的语句再次被输入服务器时，就可以直接使用已缓存的执行计划，从而跳过SQL语句生成执行计划的整个过程，进而可以提高语句的执行速度。</p><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9iVmJmZGRR?x-oss-process=image/format,png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>MySQL使用基于成本的查询优化器(Cost-Based Optimizer，CBO)。它会尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最少的一个。  优化器会根据优化规则对关系表达式进行转换，这里的转换是说一个关系表达式经过优化规则后会生成另外一个关系表达式，同时原有表达式也会保留，经过一系列转换后会生成多个执行计划，然后CBO会根据统计信息和代价模型(Cost Model)计算每个执行计划的Cost，从中挑选Cost最小的执行计划。由上可知，CBO中有两个依赖：统计信息和代价模型。统计信息的准确与否、代价模型的合理与否都会影响CBO选择最优计划。  有关优化器的原理十分复杂，这里就不进行详细讲解了，大家可以自行学习。</p><h2 id="查询执行引擎" tabindex="-1"><a class="header-anchor" href="#查询执行引擎" aria-hidden="true">#</a> <strong>查询执行引擎</strong></h2><p>在解析和优化阶段，MySQL将生成查询对应的执行计划，MySQL的查询执行引擎根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是和其他的关系型数据库那样生成对应的字节码。</p><h2 id="返回结果给客户端" tabindex="-1"><a class="header-anchor" href="#返回结果给客户端" aria-hidden="true">#</a> <strong>返回结果给客户端</strong></h2><p>如果查询可以被缓存，那么MySQL在这个阶段页会将结果存放到查询缓存中。  MySQL将结果集返回给客户端是一个增量、逐步返回的过程。在查询生成第一条结果时，MySQL就可以开始向客户端逐步返回结果集了</p>',15),s=[o];function n(c,d){return t(),e("div",null,s)}const l=a(i,[["render",n],["__file","MySQL语句执行过程.html.vue"]]);export{l as default};

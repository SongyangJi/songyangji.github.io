const e=JSON.parse('{"key":"v-e46b484a","path":"/posts/Java%E5%B9%B6%E5%8F%91%E6%8A%80%E6%9C%AF/JUC%20%E2%80%94%E2%80%94%20ConcurrentHashMap.html","title":"JUC之并发安全的HashMap —— ConcurrentHashMap","lang":"zh-CN","frontmatter":{"title":"JUC之并发安全的HashMap —— ConcurrentHashMap","date":"2021-12-12T16:15:24.000Z","categories":["JUC"],"tags":["JUC","并发集合类"],"description":"本篇文章将要介绍的 ConcurrentHashMap 是 HashMap 的并发版本，它是线程安全的，并且在高并发的情境下，性能优于 Hashtable 很多。 历史版本的演变 一句话总结 从JDK7版本的ReentrantLock+Segment+HashEntry，到JDK8版本中synchronized+CAS+HashEntry+红黑树。 JDK7的ConcurrentHashMap JDK7 采用分段锁技术，整个 Hash 表被分成多个段（默认为16段），每个段中会对应一个 Segment 段锁，段与段之间可以并发访问，但是多线程想要操作同一个段是需要获取锁的。所有的 put，get，remove 等方法都是根据键的 hash 值对应到相应的段中，然后尝试获取锁进行访问。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/Java%E5%B9%B6%E5%8F%91%E6%8A%80%E6%9C%AF/JUC%20%E2%80%94%E2%80%94%20ConcurrentHashMap.html"}],["meta",{"property":"og:site_name","content":"常潇的技术站"}],["meta",{"property":"og:title","content":"JUC之并发安全的HashMap —— ConcurrentHashMap"}],["meta",{"property":"og:description","content":"本篇文章将要介绍的 ConcurrentHashMap 是 HashMap 的并发版本，它是线程安全的，并且在高并发的情境下，性能优于 Hashtable 很多。 历史版本的演变 一句话总结 从JDK7版本的ReentrantLock+Segment+HashEntry，到JDK8版本中synchronized+CAS+HashEntry+红黑树。 JDK7的ConcurrentHashMap JDK7 采用分段锁技术，整个 Hash 表被分成多个段（默认为16段），每个段中会对应一个 Segment 段锁，段与段之间可以并发访问，但是多线程想要操作同一个段是需要获取锁的。所有的 put，get，remove 等方法都是根据键的 hash 值对应到相应的段中，然后尝试获取锁进行访问。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-17T15:13:02.000Z"}],["meta",{"property":"article:author","content":"常潇-KeepCool"}],["meta",{"property":"article:tag","content":"JUC"}],["meta",{"property":"article:tag","content":"并发集合类"}],["meta",{"property":"article:published_time","content":"2021-12-12T16:15:24.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-17T15:13:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JUC之并发安全的HashMap —— ConcurrentHashMap\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-12-12T16:15:24.000Z\\",\\"dateModified\\":\\"2024-02-17T15:13:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"常潇-KeepCool\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"历史版本的演变","slug":"历史版本的演变","link":"#历史版本的演变","children":[{"level":3,"title":"JDK7的ConcurrentHashMap","slug":"jdk7的concurrenthashmap","link":"#jdk7的concurrenthashmap","children":[]},{"level":3,"title":"JDK8的ConcurrentHashMap","slug":"jdk8的concurrenthashmap","link":"#jdk8的concurrenthashmap","children":[]},{"level":3,"title":"put流程","slug":"put流程","link":"#put流程","children":[]},{"level":3,"title":"JDK7与JDK8的区别","slug":"jdk7与jdk8的区别","link":"#jdk7与jdk8的区别","children":[]},{"level":3,"title":"Collections.synchronizedMap、Hashtable、ConcurrentHashMap区别","slug":"collections-synchronizedmap、hashtable、concurrenthashmap区别","link":"#collections-synchronizedmap、hashtable、concurrenthashmap区别","children":[]}]}],"git":{"createdTime":1708182782000,"updatedTime":1708182782000,"contributors":[{"name":"jisongyang","email":"jisongyang@kuaishou.com","commits":1}]},"readingTime":{"minutes":5.13,"words":1538},"filePathRelative":"posts/Java并发技术/JUC —— ConcurrentHashMap.md","localizedDate":"2021年12月13日","excerpt":"<p>本篇文章将要介绍的 ConcurrentHashMap 是 HashMap 的并发版本，它是线程安全的，并且在高并发的情境下，性能优于 Hashtable 很多。</p>\\n<h2> 历史版本的演变</h2>\\n<blockquote>\\n<p><em>一句话总结</em></p>\\n<p>从JDK7版本的ReentrantLock+Segment+HashEntry，到JDK8版本中synchronized+CAS+HashEntry+红黑树。</p>\\n</blockquote>\\n<h3> JDK7的ConcurrentHashMap</h3>\\n<p>JDK7 采用<strong>分段锁技术</strong>，<strong>整个 Hash 表被分成多个段（默认为16段），每个段中会对应一个 Segment 段锁</strong>，<strong>段与段之间可以并发访问，但是多线程想要操作同一个段是需要获取锁的</strong>。所有的 put，get，remove 等方法都是根据键的 hash 值对应到相应的段中，然后尝试获取锁进行访问。</p>","autoDesc":true}');export{e as data};

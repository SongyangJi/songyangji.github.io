const e=JSON.parse('{"key":"v-d2d3e9e2","path":"/posts/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html","title":"JVM垃圾回收算法和垃圾回收器","lang":"zh-CN","frontmatter":{"title":"JVM垃圾回收算法和垃圾回收器","date":"2021-12-12T18:31:40.000Z","categories":["JVM"],"tags":["JVM"],"description":"GC的基础知识 一、垃圾回收的区域 栈：栈中的生命周期是跟随线程，所以一般不需要关注。 堆：堆中的对象是垃圾回收的重点。 方法区：这一块也会发生垃圾回收，不过这块的效率比较低，一般不是我们关注的重点。 二、怎么判断对象的存活 一般有两种方式（引用计数法、可达性分析），JVM使用的是可达性分析。 1. 引用计数法 给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收（Python 在用，但主流虚拟机没有使用）。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html"}],["meta",{"property":"og:site_name","content":"常潇的技术站"}],["meta",{"property":"og:title","content":"JVM垃圾回收算法和垃圾回收器"}],["meta",{"property":"og:description","content":"GC的基础知识 一、垃圾回收的区域 栈：栈中的生命周期是跟随线程，所以一般不需要关注。 堆：堆中的对象是垃圾回收的重点。 方法区：这一块也会发生垃圾回收，不过这块的效率比较低，一般不是我们关注的重点。 二、怎么判断对象的存活 一般有两种方式（引用计数法、可达性分析），JVM使用的是可达性分析。 1. 引用计数法 给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收（Python 在用，但主流虚拟机没有使用）。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-17T15:13:02.000Z"}],["meta",{"property":"article:author","content":"常潇-KeepCool"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:published_time","content":"2021-12-12T18:31:40.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-17T15:13:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM垃圾回收算法和垃圾回收器\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-12-12T18:31:40.000Z\\",\\"dateModified\\":\\"2024-02-17T15:13:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"常潇-KeepCool\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、垃圾回收的区域","slug":"一、垃圾回收的区域","link":"#一、垃圾回收的区域","children":[]},{"level":2,"title":"二、怎么判断对象的存活","slug":"二、怎么判断对象的存活","link":"#二、怎么判断对象的存活","children":[{"level":3,"title":"1. 引用计数法","slug":"_1-引用计数法","link":"#_1-引用计数法","children":[]},{"level":3,"title":"2. 可达性分析","slug":"_2-可达性分析","link":"#_2-可达性分析","children":[]}]},{"level":2,"title":"三、 垃圾回收算法","slug":"三、-垃圾回收算法","link":"#三、-垃圾回收算法","children":[{"level":3,"title":"1. 标记-清除算法","slug":"_1-标记-清除算法","link":"#_1-标记-清除算法","children":[]},{"level":3,"title":"2. 标记-复制算法","slug":"_2-标记-复制算法","link":"#_2-标记-复制算法","children":[]},{"level":3,"title":"3. 标记-整理算法","slug":"_3-标记-整理算法","link":"#_3-标记-整理算法","children":[]},{"level":3,"title":"4. 分代收集技术","slug":"_4-分代收集技术","link":"#_4-分代收集技术","children":[]}]},{"level":2,"title":"新生代：复制算法。","slug":"新生代-复制算法。","link":"#新生代-复制算法。","children":[]},{"level":2,"title":"老年代：标记清除算法和标记整理算法","slug":"老年代-标记清除算法和标记整理算法","link":"#老年代-标记清除算法和标记整理算法","children":[]},{"level":2,"title":"Serial/Serial Old","slug":"serial-serial-old","link":"#serial-serial-old","children":[]},{"level":2,"title":"ParNew","slug":"parnew","link":"#parnew","children":[]},{"level":2,"title":"Parallel Scavenge（ParallerGC）/Parallel Old","slug":"parallel-scavenge-parallergc-parallel-old","link":"#parallel-scavenge-parallergc-parallel-old","children":[]},{"level":2,"title":"CMS（Concurrent Mark Sweep）","slug":"cms-concurrent-mark-sweep","link":"#cms-concurrent-mark-sweep","children":[{"level":3,"title":"步骤","slug":"步骤","link":"#步骤","children":[]},{"level":3,"title":"优缺点","slug":"优缺点","link":"#优缺点","children":[]}]},{"level":2,"title":"G1","slug":"g1","link":"#g1","children":[{"level":3,"title":"Region如何划分","slug":"region如何划分","link":"#region如何划分","children":[]},{"level":3,"title":"步骤","slug":"步骤-1","link":"#步骤-1","children":[]}]},{"level":2,"title":"垃圾回收器的一些重要参数","slug":"垃圾回收器的一些重要参数","link":"#垃圾回收器的一些重要参数","children":[]},{"level":2,"title":"什么时候会触发FullGC","slug":"什么时候会触发fullgc","link":"#什么时候会触发fullgc","children":[{"level":3,"title":"System.gc()方法的调用","slug":"system-gc-方法的调用","link":"#system-gc-方法的调用","children":[]},{"level":3,"title":"Metaspace区内存达到阈值","slug":"metaspace区内存达到阈值","link":"#metaspace区内存达到阈值","children":[]},{"level":3,"title":"老年代空间不足","slug":"老年代空间不足","link":"#老年代空间不足","children":[]},{"level":3,"title":"堆中分配很大的对象","slug":"堆中分配很大的对象","link":"#堆中分配很大的对象","children":[]},{"level":3,"title":"统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间","slug":"统计得到的minor-gc晋升到旧生代的平均大小大于老年代的剩余空间","link":"#统计得到的minor-gc晋升到旧生代的平均大小大于老年代的剩余空间","children":[]},{"level":3,"title":"CMS GC时出现promotion failed和concurrent mode failure","slug":"cms-gc时出现promotion-failed和concurrent-mode-failure","link":"#cms-gc时出现promotion-failed和concurrent-mode-failure","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"如何排查","slug":"如何排查","link":"#如何排查","children":[]}],"git":{"createdTime":1708182782000,"updatedTime":1708182782000,"contributors":[{"name":"jisongyang","email":"jisongyang@kuaishou.com","commits":1}]},"readingTime":{"minutes":20.69,"words":6206},"filePathRelative":"posts/JVM学习笔记/JVM垃圾回收算法和垃圾回收器.md","localizedDate":"2021年12月13日","excerpt":"<h1> GC的基础知识</h1>\\n<h2> 一、垃圾回收的区域</h2>\\n<ul>\\n<li>栈：栈中的生命周期是跟随线程，所以一般不需要关注。</li>\\n<li>堆：堆中的对象是垃圾回收的重点。</li>\\n<li>方法区：这一块也会发生垃圾回收，不过这块的效率比较低，一般不是我们关注的重点。</li>\\n</ul>\\n<h2> 二、怎么判断对象的存活</h2>\\n<p>一般有两种方式（引用计数法、可达性分析），<strong>JVM使用的是可达性分析</strong>。</p>\\n<h3> 1. 引用计数法</h3>\\n<p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收（Python 在用，但主流虚拟机没有使用）。</p>","autoDesc":true}');export{e as data};

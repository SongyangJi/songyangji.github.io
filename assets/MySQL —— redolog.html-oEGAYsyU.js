const e=JSON.parse('{"key":"v-8994829a","path":"/posts/MySQL/MySQL%20%E2%80%94%E2%80%94%20redolog.html","title":"MySQL —— Redo log","lang":"zh-CN","frontmatter":{"title":"MySQL —— Redo log","date":"2021-12-09T18:47:05.000Z","categories":["MySQL"],"tags":["MySQL"],"description":"RedoLog介绍 引言——MySQL如何做到事务的持久性 MySQL中如何修改数据呢，先从磁盘中加载数据页到InnoDB buffer pool中，然后从InnoDB buffer pool 中取出页面，进行读写操作。 那么如何做到事务的持久性呢，也就是说如何确保InnoDB buffer pool中的脏页一定会被刷新到磁盘从而做到持久化呢？ 一种最简单的方法，在事务提交成功之前，确保脏页被刷新到磁盘，换句话说，只有在脏页写到磁盘上之后，事务提交才算成功。 不过这种方案有缺点： 每次都刷新一个完整的页到磁盘性能开销很大。比如，一个页面中只有几个字节被修改的时候，刷新完整的页面到磁盘很浪费。 磁盘的随机IO很慢，一个事务修改的很多页面可能并不相邻，这个时候每个事务结束前都这样同步刷新的磁盘随机IO代价很大。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/MySQL/MySQL%20%E2%80%94%E2%80%94%20redolog.html"}],["meta",{"property":"og:site_name","content":"常潇的技术站"}],["meta",{"property":"og:title","content":"MySQL —— Redo log"}],["meta",{"property":"og:description","content":"RedoLog介绍 引言——MySQL如何做到事务的持久性 MySQL中如何修改数据呢，先从磁盘中加载数据页到InnoDB buffer pool中，然后从InnoDB buffer pool 中取出页面，进行读写操作。 那么如何做到事务的持久性呢，也就是说如何确保InnoDB buffer pool中的脏页一定会被刷新到磁盘从而做到持久化呢？ 一种最简单的方法，在事务提交成功之前，确保脏页被刷新到磁盘，换句话说，只有在脏页写到磁盘上之后，事务提交才算成功。 不过这种方案有缺点： 每次都刷新一个完整的页到磁盘性能开销很大。比如，一个页面中只有几个字节被修改的时候，刷新完整的页面到磁盘很浪费。 磁盘的随机IO很慢，一个事务修改的很多页面可能并不相邻，这个时候每个事务结束前都这样同步刷新的磁盘随机IO代价很大。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-17T15:13:02.000Z"}],["meta",{"property":"article:author","content":"常潇-KeepCool"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2021-12-09T18:47:05.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-17T15:13:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL —— Redo log\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-12-09T18:47:05.000Z\\",\\"dateModified\\":\\"2024-02-17T15:13:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"常潇-KeepCool\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"引言——MySQL如何做到事务的持久性","slug":"引言——mysql如何做到事务的持久性","link":"#引言——mysql如何做到事务的持久性","children":[]},{"level":2,"title":"redo日志格式","slug":"redo日志格式","link":"#redo日志格式","children":[]},{"level":2,"title":"Mini-transaction 的概念","slug":"mini-transaction-的概念","link":"#mini-transaction-的概念","children":[]},{"level":2,"title":"redo日志的管理","slug":"redo日志的管理","link":"#redo日志的管理","children":[{"level":3,"title":"log block","slug":"log-block","link":"#log-block","children":[]},{"level":3,"title":"redo log buffer","slug":"redo-log-buffer","link":"#redo-log-buffer","children":[]}]},{"level":2,"title":"redo log的刷盘时机","slug":"redo-log的刷盘时机","link":"#redo-log的刷盘时机","children":[]},{"level":2,"title":"redo日志文件","slug":"redo日志文件","link":"#redo日志文件","children":[]},{"level":2,"title":"log-sequence-number相关","slug":"log-sequence-number相关","link":"#log-sequence-number相关","children":[{"level":3,"title":"lsn","slug":"lsn","link":"#lsn","children":[]},{"level":3,"title":"flushed_to_disk_lsn","slug":"flushed-to-disk-lsn","link":"#flushed-to-disk-lsn","children":[]},{"level":3,"title":"checkpoint_lsn","slug":"checkpoint-lsn","link":"#checkpoint-lsn","children":[]}]},{"level":2,"title":"innodb_flush_log_at_trx_commit","slug":"innodb-flush-log-at-trx-commit","link":"#innodb-flush-log-at-trx-commit","children":[]}],"git":{"createdTime":1708182782000,"updatedTime":1708182782000,"contributors":[{"name":"jisongyang","email":"jisongyang@kuaishou.com","commits":1}]},"readingTime":{"minutes":6.39,"words":1918},"filePathRelative":"posts/MySQL/MySQL —— redolog.md","localizedDate":"2021年12月10日","excerpt":"<h1> RedoLog介绍</h1>\\n<h2> 引言——MySQL如何做到事务的持久性</h2>\\n<p>MySQL中如何修改数据呢，先从磁盘中加载数据页到InnoDB buffer pool中，然后从InnoDB buffer pool 中取出页面，进行读写操作。</p>\\n<p>那么如何做到事务的持久性呢，也就是说如何确保InnoDB buffer pool中的脏页一定会被刷新到磁盘从而做到持久化呢？</p>\\n<p>一种最简单的方法，在事务提交成功之前，确保脏页被刷新到磁盘，换句话说，只有在脏页写到磁盘上之后，事务提交才算成功。</p>\\n<p>不过这种方案有缺点：</p>\\n<ol>\\n<li><strong>每次都刷新一个完整的页到磁盘性能开销很大</strong>。比如，一个页面中只有几个字节被修改的时候，刷新完整的页面到磁盘很浪费。</li>\\n<li><strong>磁盘的随机IO很慢</strong>，一个事务修改的很多页面可能并不相邻，这个时候每个事务结束前都这样同步刷新的磁盘随机IO代价很大。</li>\\n</ol>","autoDesc":true}');export{e as data};

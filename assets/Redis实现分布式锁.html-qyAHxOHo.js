const e=JSON.parse('{"key":"v-4a61bee0","path":"/posts/Redis/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html","title":"Redis实现分布式锁","lang":"zh-CN","frontmatter":{"title":"Redis实现分布式锁","date":"2021-11-29T11:00:11.000Z","categories":["Redis"],"tags":["NoSQL","Redis","分布式锁"],"description":"分布式锁简介 分布式锁，是一种思想，它的实现方式有很多。比如，我们将沙滩当做分布式锁的组件，那么它看起来应该是这样的： 加锁 在沙滩上踩一脚，留下自己的脚印，就对应了加锁操作。其他进程或者线程，看到沙滩上已经有脚印，证明锁已被别人持有，则等待。 解锁 把脚印从沙滩上抹去，就是解锁的过程。 锁超时 为了避免死锁，我们可以设置一阵风，在单位时间后刮起，将脚印自动抹去。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/Redis/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html"}],["meta",{"property":"og:site_name","content":"常潇的技术站"}],["meta",{"property":"og:title","content":"Redis实现分布式锁"}],["meta",{"property":"og:description","content":"分布式锁简介 分布式锁，是一种思想，它的实现方式有很多。比如，我们将沙滩当做分布式锁的组件，那么它看起来应该是这样的： 加锁 在沙滩上踩一脚，留下自己的脚印，就对应了加锁操作。其他进程或者线程，看到沙滩上已经有脚印，证明锁已被别人持有，则等待。 解锁 把脚印从沙滩上抹去，就是解锁的过程。 锁超时 为了避免死锁，我们可以设置一阵风，在单位时间后刮起，将脚印自动抹去。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-17T15:13:02.000Z"}],["meta",{"property":"article:author","content":"常潇-KeepCool"}],["meta",{"property":"article:tag","content":"NoSQL"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"分布式锁"}],["meta",{"property":"article:published_time","content":"2021-11-29T11:00:11.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-17T15:13:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis实现分布式锁\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-11-29T11:00:11.000Z\\",\\"dateModified\\":\\"2024-02-17T15:13:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"常潇-KeepCool\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"锁的安全和活性保证","slug":"锁的安全和活性保证","link":"#锁的安全和活性保证","children":[]},{"level":2,"title":"主从结构故障转移时的并发问题","slug":"主从结构故障转移时的并发问题","link":"#主从结构故障转移时的并发问题","children":[]},{"level":2,"title":"锁的获取","slug":"锁的获取","link":"#锁的获取","children":[]},{"level":2,"title":"锁的释放","slug":"锁的释放","link":"#锁的释放","children":[]},{"level":2,"title":"使用Jedis实现”丐版“Redis锁","slug":"使用jedis实现-丐版-redis锁","link":"#使用jedis实现-丐版-redis锁","children":[]},{"level":2,"title":"使用Redisson中的锁","slug":"使用redisson中的锁","link":"#使用redisson中的锁","children":[]},{"level":2,"title":"Redisson中RLock的实现特点","slug":"redisson中rlock的实现特点","link":"#redisson中rlock的实现特点","children":[]},{"level":2,"title":"加锁整体流程","slug":"加锁整体流程","link":"#加锁整体流程","children":[{"level":3,"title":"构造锁","slug":"构造锁","link":"#构造锁","children":[]},{"level":3,"title":"加锁","slug":"加锁","link":"#加锁","children":[]},{"level":3,"title":"获取互斥状态","slug":"获取互斥状态","link":"#获取互斥状态","children":[]}]},{"level":2,"title":"解锁整体流程","slug":"解锁整体流程","link":"#解锁整体流程","children":[{"level":3,"title":"解锁","slug":"解锁","link":"#解锁","children":[]},{"level":3,"title":"解锁的底层逻辑","slug":"解锁的底层逻辑","link":"#解锁的底层逻辑","children":[]}]},{"level":2,"title":"Redisson的锁总结","slug":"redisson的锁总结","link":"#redisson的锁总结","children":[]}],"git":{"createdTime":1708182782000,"updatedTime":1708182782000,"contributors":[{"name":"jisongyang","email":"jisongyang@kuaishou.com","commits":1}]},"readingTime":{"minutes":13.89,"words":4168},"filePathRelative":"posts/Redis/Redis实现分布式锁.md","localizedDate":"2021年11月29日","excerpt":"<h1> 分布式锁简介</h1>\\n<blockquote>\\n<p>分布式锁，是一种思想，它的实现方式有很多。比如，我们将沙滩当做分布式锁的组件，那么它看起来应该是这样的：</p>\\n<ul>\\n<li><strong>加锁</strong>\\n在沙滩上踩一脚，留下自己的脚印，就对应了加锁操作。其他进程或者线程，看到沙滩上已经有脚印，证明锁已被别人持有，则等待。</li>\\n<li><strong>解锁</strong>\\n把脚印从沙滩上抹去，就是解锁的过程。</li>\\n<li><strong>锁超时</strong>\\n为了避免死锁，我们可以设置一阵风，在单位时间后刮起，将脚印自动抹去。</li>\\n</ul>\\n</blockquote>","autoDesc":true}');export{e as data};
